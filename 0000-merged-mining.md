- Feature Name: merged-mining
- Start Date: 2018-12-11
- RFC PR: (leave this empty)
- Hathor Issue: (leave this empty)
- Author: Pedro Henrique Santos Ferreira

# Summary
[summary]: #summary

Enable miners to mine Hathor blocks while they are also mining Bitcoin.

# Motivation
[motivation]: #motivation

The motivation is that giving the possibility to execute merged mining attracts more people (mainly mining pools) to also mine Hathor blocks, increasing the hash power of our network. With a higher hash power, we have more security against 51% attacks, so more incentive for people to use it.

# Guide-level explanation
[guide-level-explanation]: #guide-level-explanation

First, the only thing we need from Bitcoin is a place in the block to add arbitrary data, that does not influence when the block is propagate in the network. This place is the coinbase transaction.

We will need to generate a block that will be valid in both networks when propagated (Hathor and Bitcoin). This block will be called AuxPOW block. AuxPOW comes from Auxiliary Proof-of-work.

The Bitcoin blockchain will be called Parent Blockchain (the one that has the biggest difficulty) and the Hathor blockchain will be called Auxiliary Blockchain (the one that has the smallest difficulty)

We start the process creating the AuxPOW block, that has some steps:

1. We get the Bitcoin candidate block with the transactions
2. We get the Hathor candidate block
3. We hash the Hathor candidate block in bytes (32 bytes)
4. We add this hash to the Bitcoin coinbase transaction, that changes the merkle root hash (making sure the bitcoin block has to be pre-mined with the Hathor hash before)
5. The AuxPOW will be created with the coinbase transaction, the parent (Bitcoin) block hash, the parent block header, the parent coinbase merkle count, the parent coinbase merkle branch hashes and the parent markle index. These last three elements are used to validate that the coinbase transaction was really in the Merkle Tree before the mining

The work to solve the Bitcoin block after the creation of the AuxPOW is sent to be mined.

We have 3 possibilities:

1. The hash found does not solve any of pow from neither Bitcoin or Hathor block, so we just increase the nonce and continue the hash process.
2. The hash found solves the Hathor pow and does not solves Bitcoin pow, so we just propagate the AuxPOW block in the Hathor network.
  - We must add some data from the AuxPOW block to the Hathor block to confirm that the work was done
  - We add the AuxPOW block header, the coinbase transaction and the coinbase merkle informations to validate that the work is valid, that solves Hathor pow and that the coinbase transaction is linked to the Hathor block being propagated.
3. The hash found solves the pow from both blocks. In that case we just normally propagate bitcoin block and follow the steps in possibility 2 to propagate Hathor block.


# Reference-level explanation
[reference-level-explanation]: #reference-level-explanation

Creating the AuxPOW block:
  - #TODO should we add how to get bitcoin candidate block?
  - To get Hathor candidate block we just need to call `manager.get_mining_block().get_struct()` -> bytes
  - Then we hash the Hathor candidate block in bytes `hashlib.sha256(candidate_block_bytes).digest()` -> 32 bytes hash
  - We add this hash to the bitcoin coinbase transaction, that is the first transaction in the merkle tree #TODO how and where?
  - Then we create the AuxPOW block:
    - Parent coinbase transaction (Bitcoin coinbase transaction)
    - Parent block header (Bitcoin block header)
    - Parent coinbase merkle count: the number of hashes making up the branch from the coinbase transaction to the root
    - Parent coinbase merkle branch: the hashes making up the branch from the coinbase transaction to the root
    - Parent coinbase merkle index: Bitmask of which side of the merkle hash function the branch_hash element should go on. 0 means it goes on the right, 1 means on the left. It is equal to the index of the starting hash within the widest level of the merkle tree for this merkle branch.


To validate that the block generated by merged mining is valid we must:
  - Add the AuxPOW data to the Hathor block `merge_mining_block` field #TODO should we call like that or maybe a generic field `aux_data`, so it can be used for other purposes also?
  - Calculate the hash of the AuxPOW block header to see if it solves the Hathor pow
  - Using the coinbase transaction and the merkle data in the AuxPOW block we can validate that the previous Hathor block was linked to this AuxPOW block before the mining.
    - We get the coinbase transaction and go up the merkle branch using the merkle branch field and the merkle index field to know which hash should be first or second.
    - When we get to the merkle root, we compare the calculated root with the merkle root in the block header to see if they are equal. If they match, the Hathor block was linked to the Bitcoin block before the mining, so it's a valid work


# Rationale and alternatives
[rationale-and-alternatives]: #rationale-and-alternatives

- We are using the same specifications of Namecoin and Elastos, what is good because people are already used to it.
- Merge mining is good in terms of increasing hash power of the network and also good for marketing, since we can argue that you are not using any other energy to mine our blocks.

# Unresolved questions
[unresolved-questions]: #unresolved-questions

- Should we issue the same quantity of tokens for blocks mined with and without merge mining?
- Should we prepare ourselves to allow merged mining in our platform us being the parent blockchain? We would need a place to add arbitrary data that does not influence when propagating to the network.

# Future possibilities
[future-possibilities]: #future-possibilities

- In the future we may support mine blocks in more than one auxiliary blockchain in the same time, for that we would need to update the code to support it #TODO