* Feature name: Integrating WalletConnect on our wallets
* Start date: 17/03/2023
* Initial Document
* Author: @andreabadesso

## Table of Contents

- [Summary](#summary)
- [Motivation](#motivation)
- [Acceptance Criteria](#acceptance_criteria)
- [Overview of WalletConnect](#overview)
	* [What is it?](#overview__what_is_it)
	- [How does it works](#overview__how_does_it_work)
	- [Is it secure?](#overview__is_it_secure)
  - [Privacy](#privacy)
	- [Resources](#overview__resources)
- [Guide-level explanation](#guide_level_explanation)
	- [UI](#guide_level_explanation__ui)
	- [API](#guide_level_explanation__api)
	- [Design Decisions](#guide_level_explanation__design_decisions)
- [Reference-level explanation](#reference_level_explanation)
	- [Initialization](#reference_level_explanation__initialization)
	- [Pairing](#reference_level_explanation__pairing)
	- [Handling Session Proposals](#reference_level_explanation__handling_session_proposals)
	- [Handling Session Requests](#reference_level_explanation__handling_session_requests)
- [Conclusion](#conclusion)
	- [Pros](#conclusion_pros)
	- [Cons](#conclusion_cons)
- [Task Break-down](#task_breakdown)

<a name="summary"/>

## Summary

The idea of this document is to give an overview of WalletConnect and evaluate whether it is or not a good option for building our WebWallet and giving support to `dApps` on the Hathor Network

<a name="motivation"/>

## Motivation

Today, web3 is largely web-native. Crypto users are used to working with web wallets, which quickly have become the standard for operations such as login authentication, and performing other actions within DEXes and other `dApps`.

With Nano Contracts approaching, we need to offer our users and builders a way to let our official wallets communicate with web apps.

There will be a single code for integration with Nano Contracts in the wallet lib that any third-party wallets that wish to integrate can use. However, many users and use cases will prefer to work only with our official wallets, so we should enable our mobile and desktop wallets to communicate with the apps being built.

<a name="acceptance_criteria"/>

## Acceptance Criteria

* Evaluation of whether WalletConnect is a good fit with Hathor (i.e. if it supports all operations dapps on hathor will need)
* Evaluate if the technology is ready for being used in production
* Evaluate if the code is well tested and have it's security checked
* Propose a working solution for `dApps` to interact with

<a name="overview_of_wallet_connect"/>

## Overview of WalletConnect

<a name="overview__what_is_it"/>

### What is it?

WalletConnect is an open-source protocol that enables secure and seamless communication between decentralized applications (dApps) and wallets on various blockchains. By establishing a remote connection using end-to-end encryption, WalletConnect allows users to interact with dApps through their preferred wallet without exposing their private keys.

<a name="overview__how_does_it_work"/>

### How does it work?

#### 1.  User Flow

User visits a new website that requires a Sign session for submitting transactions and Auth for authentication

1.  `dApp` displays QRCode or deep link
	1. A connection is established with a Relay server and a topic is subscribed
	2. A `session_proposal` message is sent on the channel
2.  User scans QRCode or redirects to wallet (deep-link)
	1. The wallet connects to the same relay server and the same topic is subscribed
1.  Popup with session proposal and authentication request appears on the Wallet
	1. The wallet can either accept or reject the proposal
1.  User approves session request and authenticates
1.  User returns to website after prompt success
1.  User is now authenticated and has a sign session established with the `dApp`

#### 2. Relay Server

The relay server acts as a message broker between the wallet and the dApp. It is responsible for transmitting encrypted messages between the two parties, ensuring that no sensitive information is exposed during communication. The relay server uses the WebSocket protocol to establish real-time connections and does not store any data or have access to the contents of the messages.

The communication process involves the following steps:

**1. Session Request**

The dApp initiates a connection request by generating a QR code containing the connection details. The user then scans this QR code using their wallet, which establishes a WebSocket connection with the relay server.

WalletConnect expects an `Authorization: Bearer <signed jwt>` header when establishing the Websocket connection. Where websocket headers are not supported i.e. browsers, use url query param `?auth=<signed jwt>`. Server should support both of these mechanisms.

The `client_id` is a [DID](https://www.w3.org/TR/did-core/) of the public key for the key pair generated by the client when instantiating the SDK and persisted for the entire lifecycle.

Clients will generate a unique id per app initialization which will be used as a subject when signing a JWT with the `client_id` as the issuer and is persisted through duration of the app lifecycle.

This is the method used to sign the JWT, extracted from the [walletconnect/monorepo](https://github.com/WalletConnect/walletconnect-monorepo/blob/5faa1cc2a8936644f46d946cec08c8af63b082f7/packages/core/src/controllers/crypto.ts#L65) 

```typescript
  public signJWT: ICrypto["signJWT"] = async (aud: string) => {
    this.isInitialized();
    const seed = await this.getClientSeed();
    const keyPair = relayAuth.generateKeyPair(seed);
    const sub = generateRandomBytes32();
    const ttl = CRYPTO_JWT_TTL;
    const jwt = await relayAuth.signJWT(sub, aud, ttl, keyPair);
    return jwt;
  };
```

`this.getClientSeed`  returns a random 32 bytes string that it will either generate or return from storage (it stores after generating)
`relayAuth.generateKeyPair` generates a key pair using `ed25519`
`sub` is the subject, which is an unique id (per client) that will be used when signing the JWT with the `client_id` as the issuer. It's also persisted through the duration of the app lifecycle
`ttl` is a constant, set to one day

The jwt is then signed using the `relayAuth.signJWT` method, this is the implementation:

```typescript
async function signJWT(  
  sub: string,  
  aud: string,  
  ttl: number,  
  keyPair: ed25519.KeyPair  
) {  
  const header = { alg: JWT_ALG, typ: JWT_TYP };  
  const iss = encodeIss(keyPair.publicKey);  
  const iat = fromMiliseconds(Date.now());  
  const exp = iat + ttl;  
  const payload = { iss, sub, aud, iat, exp };  
  const data = encodeData({ header, payload });  
  const signature = ed25519.sign(keyPair.secretKey, data);  
  return encodeJWT({ header, payload, signature });  
}
```

And here is an example JWT:

```javascript
eyJhbGciOiJFZERTQSIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJkaWQ6a2V5Ono2TWtvbndvdXhjVjVjd3hVRUF4UTd3MUxGRzdIcXBxeWFyRkNTRUhtQ0dmYzdhNiIsInN1YiI6Ijk5OTZlNjQ5NDcyZjYxNDEzZjBhNTdiZTY2MzkyZGU5NmY4YzZlM2EwNDI1ZTQwMDE0ZjViNjgzOWNlNmIyZmMiLCJhdWQiOiJ3c3M6Ly9yZWxheS53YWxsZXRjb25uZWN0LmNvbSIsImlhdCI6MTY3OTA2MzA4NCwiZXhwIjoxNjc5MTQ5NDg0fQ.aIuUBxAKgfmq_Vs5BfzEHcmA-PN2IkbJMxS72_pUx2vZ0jylnAV-GNgwzQH0sQOf4a753T_Wofjub47qLccYCQ
```

Which, when decoded, has the following data:

```json
{
  "iss": "did:key:z6MkonwouxcV5cwxUEAxQ7w1LFG7HqpqyarFCSEHmCGfc7a6",
  "sub": "9996e649472f61413f0a57be66392de96f8c6e3a0425e40014f5b6839ce6b2fc",
  "aud": "wss://relay.walletconnect.com",
  "iat": 1679063084,
  "exp": 1679149484
}
```


**2. dApp <-> Wallet linking mechanism**

When the `dApp` gernerates the QRCode for establishing a connection, it generates a topic and subscribes to it, waiting for a `session_proposal` message from the Wallet.

Here is an example URI:

```json
wc:4cfe8a81c7d1c831037a2e766d2797a0d218132cde9b7b2cd3f9b062982e8e38@2?relay-protocol=irn&symKey=b726721e41a339e828597ccf0108cf697b64234c31f61643c148346a0f2a12d5
```

Here is an example subscribe message:

```json
{
  "id": 1679064241504544,
  "jsonrpc": "2.0",
  "method": "irn_subscribe",
  "params": {
    "topic": "4cfe8a81c7d1c831037a2e766d2797a0d218132cde9b7b2cd3f9b062982e8e38"
  }
}
```

After scanning, the Wallet parses the URI, extracting the `symKey` which will be used to encrypt messages from now on, the `topic` and the `relay`

It then connects to the relay server (websocket) and subscribes to the topic shared through the `URI`

After the Wallet is also connected to the relay and subscribed to the topic, the `dApp` sends an encrypted `session_proposal` message to the relay server, which then forwards it to the `Wallet`.

Here is an example `session_proposal` message:

```json
{
    "id": 1679064071906409,
    "params": {
        "id": 1679064071906409,
        "pairingTopic": "bb05ad453f1d2cb519ab2b9d69b0776ae4d834fe115cce60a2b1eedaf497b21c",
        "expiry": 1679064408,
        "requiredNamespaces": {
            "hathor": {
                "methods": [
                    "hathor_signMessage"
                ],
                "chains": [
                    "hathor:mainnet"
                ],
                "events": []
            }
        },
        "optionalNamespaces": {},
        "relays": [
            {
                "protocol": "irn"
            }
        ],
        "proposer": {
            "publicKey": "9c4bfcd9c156f23a95ee4a6bd74b68af27f40e17800fd3272d29386e228b9643",
            "metadata": {
                "description": "React App for WalletConnect",
                "url": "http://localhost:3000",
                "icons": [
                    "https://avatars.githubusercontent.com/u/37784886"
                ],
                "name": "React App"
            }
        }
    }
}
```

The Wallet then approves or reject this message, here is an `approve_session` example message, as it is sent from the Wallet to the `dApp` through the relay server, before being encrypted using the `symKey`:

```json
{
    "id": 1679064630962451,
    "relayProtocol": "irn",
    "namespaces": {
        "hathor": {
            "accounts": [
                "hathor:mainnet:HRZZrkp3BcCdvL5RFd4sb3BqXienb5V5yr"
            ],
            "chains": [
                "hathor:mainnet"
            ],
            "events": [],
            "methods": [
                "hathor_signMessage"
            ]
        }
    }
}
```

Once the approve_session message is received and processed by the dApp, the secure communication channel between the dApp and the wallet is established, and they can exchange encrypted messages through the relay server.

The messages are encrypted using [ChaCha20-Poly1305](https://en.wikipedia.org/wiki/ChaCha20-Poly1305), the implementation for the `encrypt` method can be see [here](https://github.com/WalletConnect/walletconnect-monorepo/blob/557b9e295039285cdbab2e3183211095aee9e94a/packages/utils/src/crypto.ts#L63). On the original spec, it does not accept changing the encryption algorithm.

Here is a flowchart illustrating this linking process:

```mermaid
graph TB
  dAppGenerateQR[dApp: Generate QR Code] -- URI --> walletScanQR[Wallet: Scan QR Code]
  walletScanQR -- Extract symKey, topic, relay info --> walletConnect[Wallet: Connect to Relay Server]
  walletConnect -- Subscribe to topic --> walletSubscribed[Wallet: Subscribed to Topic]
  dAppConnect[dApp: Connect to Relay Server] --> dAppSubscribed[dApp: Subscribed to Topic]
  dAppSubscribed -- Send encrypted session_proposal --> walletSubscribed
  walletSubscribed -- Receive session_proposal --> walletReview[Wallet: Approve or Reject]
  walletReview -- Send encrypted approve_session --> dAppReceiveApprove[dApp: Receive approve_session]
  dAppReceiveApprove --> dAppSecureCommunication[dApp: Establish secure communication]
  walletReview --> walletSecureCommunication[Wallet: Establish secure communication]
```


**3. Message Exchange** The wallet and the dApp can now exchange encrypted messages through the relay server using the `symKey` shared through the URI (either via QRCode or by Deep-linking).

**4. Session Termination** Either the wallet or the dApp can terminate the session by sending a disconnection message. The relay server then closes the WebSocket connection.

#### 3. Relay Server Concepts

| Field        | Description                                                                                           |
|--------------|-------------------------------------------------------------------------------------------------------|
| Topic        | A string identifier used by clients to publish and subscribe to messages.                             |
| Subscription | Requested by a client and remains active until the client requests to unsubscribe.                     |
| Publication  | Requested by a client; the Relay server is responsible for routing the message to its recipient.       |
| Message      | A utf8 string sent when publishing, to be routed to its recipient.                                    |
| Tag          | An integer used as metadata to identify the type of message being sent.                               |
| TTL          | The maximum amount of time (in seconds) a message should be cached in the relay serverif undelivered.                    |
| Prompt       | A boolean flag used to identify if a message is relevant to registered webhooks.                      |

<a name="overview__is_it_secure"/>

### Is it secure?

The information sent between `dApps` and wallets is encrypted symmetrically with a key that only these two entities possess

The key is sent directly to the wallet from the `dApp`. Whether users scan through the QR code or choose deep-link with the wallet, there are no intermediaries, so as long as the `symKey` is not leaked, the communication is safe.

The protocol as is currently designed does not support ephemeral keys, [on their web3wallet implementation](https://github.com/WalletConnect/walletconnect-monorepo/tree/v2.0/packages/web3wallet), the symKey is stored on localStorage during the entire session. **An important remark is that the `symKey` is being stored in plain-text on the device's localStorage.**. If we choose to use WalletConnect, we need to extend their SDK and encrypt it.

This key is generated using the `generateRandomBytes32` method, here is its implementation:

```typescript
export function generateRandomBytes32(): string {
  const random = randomBytes(KEY_LENGTH);
  return toString(random, BASE16);
}
```

`randomBytes` is a method from a library called `stablelib`, which can be seen [here](https://github.com/StableLib/stablelib/blob/a89a438fcbf855de6b2e9faa2630f03c3f3b3a54/packages/random/random.ts#L18).

The implementation for the PRNG used by it can be seen [here](https://github.com/StableLib/stablelib/blob/a89a438fcbf855de6b2e9faa2630f03c3f3b3a54/packages/random/source/browser.ts) for when it's used on a browser, and [here](https://github.com/StableLib/stablelib/blob/a89a438fcbf855de6b2e9faa2630f03c3f3b3a54/packages/random/source/node.ts) when it's used on node.js

Given that the shared key is not leaked, the message exchange should be secure from network man in the middle attacks as it is only displayed as a QRCode and scanned on the Wallet

One important remark here is that the `symKey` is generated client-side by the `dApp`. The problem with this approach is that `dApps` can generate unsafe random bytes and expose themselves to attack vectors.

<a name="privacy"/>

### Privacy

As described before, there is no current production-ready implementation of the WalletConnect Relay Server, so we are forced to using their Cloud Infrastructure

The privacy policy for WalletConnect can be read [here](https://walletconnect.com/privacy)

This is the Cloud Infrastructure section:


> We offer hosted infrastructure for users of the WalletConnect Cloud. Our infrastructure consists of components such as a relay server, load balancer, and other infrastructure that receives and transmits encrypted data between known parties.
> 
> Data processed may include:
> 
> * IP address may be temporarily logged to prevent DDOS attacks.
> * Encrypted data payloads may be stored so that they can be retrieved by clients
> * A randomly generated clientid used to retrieve messages
> * Metadata about the protocol such as the message tag and projectId
> * SDK user agent and version
> * Country and region

If we choose to use WalletConnect, I suggest we add a modal with a notice explaining that we are currently using the WalletConnect Cloud Infrastructure, poiting to their privacy policy and explaining that the data listed above might be tracked.


<a name="overview__resources"/>

### Resources

**Github**: https://github.com/WalletConnect
**Docs**: https://docs.walletconnect.com/2.0/
**Medium**: https://medium.com/walletconnect/
**Sign Reference API**: https://docs.walletconnect.com/2.0/specs/clients/sign/client-api

### SDK

WalletConnect consists of two SDKs available for both the `dApps` and the Wallets: [`Web3Modal`](https://github.com/WalletConnect/web3modal) and [`Web3Wallet`](https://github.com/WalletConnect/walletconnect-monorepo/tree/v2.0/packages/web3wallet):

> Web3Modal is a library that makes it easy to connect users to your `dApp` and interact with the blockchain

It's used to display a HTML popup with the QRCode containing the URI for the peering, it uses the [core](https://github.com/WalletConnect/walletconnect-monorepo/tree/v2.0/packages/core) library to generate the necessary attributes.

> Web3Wallet simplifies the process of integrating wallets into `dApps` by combining the Sign and Auth APIs into a single module

The `web3wallet` library is used on the Wallets for the pairing and message exchange

#### Web3Wallet SDK

> The Web3Wallet SDK allows you to easily connect your Web3 wallet with `dApps`. It provides a simple and intuitive interface for `dApps` to request actions such as signing transactions and interacting with smart contracts on the blockchain. The SDK is designed to work with any blockchain, making it easy to support multiple chains without the need for separate integration code. (https://docs.walletconnect.com/2.0/web3wallet/about)

It's basically a library that provides a single API for the [Sign API](https://docs.walletconnect.com/2.0/api/sign) and the [Auth API](https://docs.walletconnect.com/2.0/api/auth)

#### WalletConnect Cloud

The javascript SDK requires a `projectId` which is supposed to be registered at their WalletConnect cloud, so it can use the WalletConnect infrastructure "for free". 

Note: There is currently no stable open-source implementation of the relay server infrastructure, so this step is really necessary.

<a name="guide_level_explanation"/>

## Guide-level explanation

To go along with this design document, a proof-of-concept has been developed which can be accessed [here](https://github.com/HathorNetwork/hathor-wallet-mobile/pull/245)

The main design decision here is to keep all the business-logic inside the mobile app (or the wallet-desktop), only exposing a JSON-RPC API to the `dApps`, being strict on what methods we want to make available

<a name="guide_level_explanation__ui"/>

### UI

There are two parts of the UI when using wallet-connect: The `dApp` UI, which should basically be a QRCode with the information to connect, as described in the "How does it work?" section of this document and that is already provided with the `Web3Modal` library, described in the SDK section of this document.

The other part would be the wallet, which can be either our already existing mobile-wallet or the desktop-wallet, or both.

On the proof-of-concept, I added the WalletConnect to the wallet-mobile project, here is an example of scanning, pairing and answering a JSON-RPC request:


<video src="https://user-images.githubusercontent.com/3586068/225664948-fd45d6ff-6e1a-4585-99e0-6ea2b914ee54.mov"></video>


<a name="guide_level_explanation__api"/>

### API

For the first implementation of the WebWallet, I suggest we expose the following JSON-RPC APIs


#### 1. Prove ownership of an address

`dApps` might ask the wallets to sign an arbitrary message using an address, this method will receive a string and return a string with the signed message encoded in `base64`

This method should be similar to the Ethereum's `personal_sign` which is part of the Ethereum JSON-RPC interface.

The idea is to allow `dApps` to request an arbitrary data to be signed with a specific address private key, to be able to prove the ownership of that address.

This method will calculate an Hathor specific signature with `sign(keccak256("\x19Hathor Signed Message:\n" + len(message) + message)))`. By adding this prefix, we can ensure that the message will be specific to Hathor and prevent misuse where a malicious dApp could sign a transaction for instance


#### 2. Sign a transaction

The `dApp` should be able to send a transaction to have its inputs validated and signed from the wallets

The wallets should display the same UI from the already existing send transaction screen, but with a rejection button:

<img width="544" alt="Pasted image 20230316114533" src="https://user-images.githubusercontent.com/3586068/225664910-28f3dfba-f508-477f-9950-67ef77dad570.png">

On the mobile wallet, we should also implement a token action confirmation screen for displaying complete information about different token actions, like utxos used, outputs created, token name, token symbol, etc...

The mechanism for signing a transaction is the following:

1. The wallet responds an RPC call requesting inputs and answers with inputs taken from a trusted fullnode or wallet-service backend
1. The wallet receives raw transaction bytes and parses it locally
1. The wallet gathers information on this transaction's from the connected (and trusted) fullnode or wallet-service backend

We should also make sure to never trust information received by the `dApp`, all transaction inputs and outputs should be fetched by a trusted fullnode, specifically the one the wallet is currently connected to.


#### 3. Get token balance
  
The `htr_getAddressBalance` API provides a way to retrieve the current balance of a specified token


#### 4. Get utxos for a transaction

Unlike Ethereum, which uses an account-based model, Hathor employs a UTXO model for managing token balances. In order to create a transaction on a decentralized application (dApp), it is necessary to locate available UTXOs for a specified token. The `htr_getUtxosForToken` API allows developers to find and retrieve UTXOs related to a particular token, facilitating the creation of new transactions.

Before answering, the wallet must display a confirmation modal asking the user for permission to search for utxos for a given token and a given value, or authorities for a given token. The modal must also display the utxos that it will respond and ask for confirmation.


<a name="guide_level_explanation__design_decisions"/>

### Design Decisions

#### Namespaces

> A namespace is a standardized object defined by the [Chain Agnostic Improvement Proposal (CAIP)](https://github.com/ChainAgnostic/CAIPs) that ensures a common industry standard for chain agnostic purposes. You will encounter two namespaces: the **proposal namespace** and the **session namespace** when connects wallets and dapps.

I wrote a CAIP-2 proposal [here](./0002-caip-2.md) which should be submitted as a PR on [this](https://github.com/ChainAgnostic/namespaces) repository.

Here is an example of a session approval message, passing the namespace 

```json
{
...
	"namespaces": {
		"hathor": {
			"accounts": [ "hathor:mainnet:HRZZrkp..." ]
			"chains": [ "hathor:mainnet" ],
			"events": [],
			"methods": [
				"hathor_signMessage"
			]
		}
	}
...
}
```

#### Accounts

> CAIP-10 defines a way to identify an account in any blockchain specified by CAIP-2 blockchain id.

For the account, since Hathor is a utxo-based blockchain and we are still studying the [Account Abstraction](https://ethereum.org/en/roadmap/account-abstraction/) project (which might change this), I decided to use the first address of the wallet (derived from the `m/44'/280'/0'/0/0` path), as the unique identifier for the account

A CAIP-10 proposal document was created and can be read (and reviewed) [here](./0003-caip-10.md)

<a name="reference_level_explanation"/>

## Reference-level explanation

In the mobile-wallet, which I used for the proof-of-concept and can be seen [here](https://github.com/HathorNetwork/hathor-wallet-mobile/pull/245/), I used the `@walletconnect/web3wallet` library for all interaction with `wallet-connect`

<a name="reference_level_explanation__initialization"/>

### Initialization

First, we need to instanciate  `@walletconnect/core`, passing a `PROJECT_ID` that is registered on https://walletconnect.com

This `PROJECT_ID` will be described in-depth in the External Tasks section of this document

Using the `core` instance, we can init the `@walletconnect/web3wallet` instance passing it and some metadata with information about the wallet:

```javascript
  // This metadata object can be used by dApps to display information on connected clients
  const metadata = {
    name: 'Hathor WalletConnect PoC',
    description: 'Proof-of-concept using WalletConnect to connect to a Hathor dApp',
    url: 'https://hathor.network/',
    icons: ['hathor_logo.png'],
  };
  
  const web3wallet = yield call(Web3Wallet.init, {
    core,
    metadata,
  });
```

After that, we should listen to the `web3wallet` events and react to it, here is an example `setupListeners` method using redux-saga's `eventChannels`:

```javascript
export function* setupListeners(web3wallet) {
  const channel = eventChannel((emitter) => {
    const listener = (state) => emitter(state);
    
    web3wallet.on('session_approval', (proposal) => {
      emitter({
        type: 'WC_SESSION_APPROVAL',
        data: proposal,
      });
    });

    web3wallet.on('session_request', (event) => {
      emitter({
        type: 'WC_SESSION_REQUEST',
        data: event,
      });
    });

    web3wallet.on('session_proposal', async (proposal) => {
      emitter({
        type: 'WC_SESSION_PROPOSAL',
        data: proposal,
      });
    });

    return () => {
      web3wallet.removeListener('session_approval', listener);
      web3wallet.removeListener('session_request', listener);
      web3wallet.removeListener('session_proposal', listener);
    };
  });

  try {
    while (true) {
      const message = yield take(channel);

      yield put({
        type: message.type,
        payload: message.data,
      });
    }
  } finally {
    if (yield cancelled()) {
      channel.close();
    }
  }
}
```

<a name="reference_level_explanation__pairing"/>

### Pairing

On both wallets, we need to enable the user to scan a QRCode containing the connection URI and also allow him to manage his connected sections

Here is an example `saga` of handling the URI pairing, using the `@walletconnect/core` library:

```javascript
export function* onQrCodeRead(action) {
  const { web3wallet, core } = yield select((state) => state.walletConnect);

  if (!web3wallet) {
    throw new Error('Wallet connect instance is new and QRCode was read');
  }

  const { payload } = action;

  try {
    yield call(() => core.pairing.pair({ uri: payload }));
    console.debug('Pairing...');
  } catch(e) {
    console.error('Error pairing with QrCode: ', e); 
  }
}
```

<a name="reference_level_explanation__handling_session_proposals"/>

### Handling session proposals

As described on the "How does it work" section of the WalletConnect overview, a `session_proposal` event is received by the wallet just as soon as the connection is established with the relay server, so we need to handle it by displaying the proposal request to the user with a popup to accept or reject it.

Here is an example saga handling the `onSessionProposal` event:

```javascript
export function* onSessionProposal(action) {
  const { id, params } = action.payload;
  const { web3wallet } = yield select((state) => state.walletConnect);

  const wallet = yield select((state) => state.wallet);
  const addresses = wallet.newAddresses;

  console.log(action.payload);

  const onAcceptAction = { type: 'WALLET_CONNECT_ACCEPT' };
  const onRejectAction = { type: 'WALLET_CONNECT_REJECT' };

  yield put(setWalletConnectModal({
    type: MODAL_TYPES.SESSION_PROPOSAL,
    show: true,
    metadata: {
      title: `${params.proposer.metadata.name} wants to connect.`,
      description: params.proposer.metadata.description,
      requiredMethods: params.requiredNamespaces.hathor.methods,
    },
    onAcceptAction,
    onRejectAction,
  }));

  const { accept } = yield race({
    accept: take(onAcceptAction.type),
    reject: take(onRejectAction.type),
  });

  if (!accept) {
    yield call(() => web3wallet.rejectSession({
      id: params.id,
      reason: {
        code: REJECTION_CODE,
        message: 'User rejected the session',
      },
    }));
  }

  try {
    const sessionApproved = yield call(() => web3wallet.approveSession({
      id,
      relayProtocol: params.relays[0].protocol,
      namespaces: {
        hathor: {
          accounts: accept.payload.selectedAddresses.map((address) => `hathor:mainnet:${address}`),
          chains: [`hathor:${network}`],
          events: [],
          methods: HATHOR_ALLOWED_METHODS,
        },
      },
    }));

    yield call(refreshActiveSessions);
  } catch(e) {
    console.log('Error handling session proposal: ', e);
  }
}
```

In this example, we are displaying a modal describing the methods that the `dApp` is requesting and after approal, it sends an `session_approved` method through the `web3wallet` instance.

The modal must display a list of the wallet's addresses and allow the user to select one or more of them to connect (see the design decisions section)

<a name="reference_level_explanation__handling_session_requests"/>

### Handling session requests

After the session is established, we will receive RPC requests through the `session_request` event, here is an example request:

```json
{
    "id": 1679071024881602,
    "topic": "d5b50afb3541aea8ce9c8a0341a18bff913d3d83602084424cffcd3b81c28626",
    "params": {
        "request": {
            "method": "hathor_signMessage",
            "params": {
                "address": "HRZZrkp3BcCdvL5RFd4sb3BqXienb5V5yr",
                "message": "Please sign me!"
            }
        },
        "chainId": "hathor:mainnet"
    }
}
```

As we can see, in the params we can see the requested method and the params, in this case, the address to sign with and the message for the `signMessage` RPC API

Handling this specific message will be described in the API section of the reference-level explanation

### API format, parameters and response

#### 1. Prove ownership of an address

When requested, this method should display a modal asking user for confirmation before continuing. In this case, it should display the `message` and the `address` the `dApp` is requesting it to sign

This method should validate if the requested address belongs to the current wallet (with the limitation of only validating if the address is reachable with the fullnode's current `MAX_GAP`), retrieve its `privateKey` and sign the message, returning a base64 signed result. 

**Params**:
* `address`: Base58 address to request ownership proof
* `message`: Arbitrary message to sign

**Response**:

```javascript
{
	id: 'message_id',
	jsonrpc: '2.0',
	result: 'signed-data-in-base64'
}
```

#### 2. Sign a transaction

This method should receive a full transaction and after displaying a modal with the complete transaction information, including the transaction type (regular tx, token action, nano-contract execution, etc...) in a user-friendly format and receiving the approval from the user, it should sign all inputs and answer with the `txHex` in base64 format.

**Params**:
* `inputs`: List of transaction inputs
* `outputs`: List of transaction outputs
* `metadata?`: Transaction metadata, like `tokenName` and `symbol` for token creation transactions

**Response**:

```javascript
{
	id: 'message_id',
	jsonrpc: '2.0',
	result: 'signed-txHex'
}
```

#### 3. Get token balance

This method should receive a token identifier and after displaying a confirmation modal, fetch the balance for this token on the current account and return.

**Params**:
* `token_id`: Token identifier

**Response**:

```javascript
{
	id: 'message_id',
	jsonrpc: '2.0',
	result: 50
}
```

#### 4. Get utxos

This method should be used to request available utxos for a given `token_id`

**Params**:
* `token_id`: The token identifier
* `authority?`: The type of authority to search for or null, valid options are `mint` and `melt`
* `addresses?`: List of addresses to filter utxos
* `totalAmount?`: Total sum amount, should be null if searching for authorities
* `count`: Count of utxos to fetch
* `ignoreLocked`: If we should ignore locked utxos, can be `true` or `false`

**Response**:

```javascript
{
	id: 'message_id',
	jsonrpc: '2.0',
	result: [
		{ txId: '...', index: 0, value: 50 },
		{ txId: '...', index: 0, authority: 'melt' },
	]
}
```

<a name="conclusion"/>

## Conclusion

The WalletConnect ecosystem supports natively any EVM-chain with little effort but it can also be used for non-EVM chains with some good standards, the documentation is not the greatest but the code is clear and organized with good open-source examples.

There are many projects using WalletConnect in production, like Aave, Uniswap, PancakeSwap and many others, it's a solid project and is in production for some years now

Also, many wallets support WalletConnect, including Ledger (through the Ledger Live app)

The `dApps` have no access to private keys, they are kept on our wallets and everything is done inside them before the signed transactions and other responses are sent to the `dApp` through a channel that is encrypted using a key that is only shared through a QR Code.

WalletConnect is agnostic to what wallet it's used on, so we can use it on our mobile wallet and desktop wallet, including Ledger

In my opinion, WalletConnect is a very viable project for our goals and is currently the best option so far.

**The only problem with it is that the production Relay server which is used for communication between the `dApp` and the wallets is not open-source. There is a minimal implementation [here](https://github.com/WalletConnect/relay), but it's only a sample implementation and should not be used in production.** If we decide that we don't want to use their public relay server, we need to implement our own from scratch.

<a name="conclusion_pros"/>

### Pros

- [ ] We don't have to implement a new wallet, we can use our existing wallets
- [ ] Supports hardware wallets as it is wallet-agnostic
- [ ] Very well-known in the crypto space, used by many `dApps` in production
- [ ] Has great libraries, including `react-native` and `react` javascript libraries which can be used on our wallets

<a name="conclusion_cons"/>

### Cons
- [ ] **The production relay server is not open-source.**, we would have to develop our own if we don't want to depend on them

<a name="task_breakdown"/>

## Task break-down

| Task | Dev/days |
| --- | --- |
| Implement the methods described in the API section| 2 |
| Implement the walletConnect saga | 2 |
| New screens for pairing and handling sessions and modals | 2 |
| Implement feature toggles | 0.5 |
| QA and internal testing | 2 |


